智能指针  

异常里可能存在内存泄漏的解决

![image-20220605002455246](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220605002455246.png)



拷贝构造到底是开一块新空间还是模拟原生指针的行为？

 

delete nullptr不报错

C++98 拷贝时  管理权转移 使得被拷贝的对象悬空  是一种失败的设计

C++11吸收了boost库里的智能指针 只是稍微改变了一下

[C++11中=delete的巧妙用法_爱就是恒久忍耐的博客-CSDN博客_c++ delete](https://blog.csdn.net/whahu1989/article/details/90648536) 



拷贝时造成析构多次的问题

unique_ptr  仅仅用于管理资源 不支持拷贝  防拷贝实现

 



shared_ptr 

1. 加一个成员变量计数实现只析构一次

多个对象每个都有自己的数字 指向同一块资源的计数可能不同

2. 搞一个静态成员

多个指针 管理不同的资源 计数却相同显然不合理



借助指针实现同一块资源的计数相同，由构造函数构造计数





=和&运算符不重载会生成

赋值重载得先处理之前的资源  delete之后的指针给了一个新的指向

赋值重载可能是更改两个已经有了指向的指针   所以必须处理之前的资源

还得考虑自己给自己赋值

还得考虑一块资源是一个还是多个指针管理 如果只有一个呢？

指针自己给自己赋值的情况  管理的资源相同的情况下赋值

![image-20220605120959601](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220605120959601.png)





现代写法  思考赋值的目的（目的就是两个对象管理同一块空间）



线程安全

循环引用

与boost库的联系
