# C++11

## 什么是C++11

C++11标准是 ISO/IEC 14882:2011 - Information technology -- Programming languages -- C++ 的简称 [1] 。

C++11标准由[国际标准化组织](https://baike.baidu.com/item/国际标准化组织/779832)（ISO）和[国际电工委员会](https://baike.baidu.com/item/国际电工委员会/2876390)（IEC）旗下的**C++标准委员会**（ISO/IEC JTC1/SC22/WG21）于2011年8月12日公布 [2] ，并于2011年9月出版。2012年2月28日的国际标准草案(N3376)是最接近于C++11标准的草案（仅编辑上的修正）。此次标准为C++98发布后13年来第一次重大修正。--百度百科

> 翻译一下，2011年发布的C++标准，对C++98的一次重大修正。

## 新特性

下面的新特性有{}初始化，auto,declytype,nullptr,范围for，STL的变化，左右值引用，lambda表达式，包装器

> 智能指针和线程库之后补充。

### {}初始化

C++11提供了{}初始化的方法。

#### 简单实例

```c++
int main()
{
//{}的简单使用
	int arr1[] = {1,2,3,4,5};
	int arr2[]{ 1,2,3,4,5 };

	pair<int, int>(1, 1);
	pair<int, int>{1,1};

	pair<string, int>* pr = new pair<string, int>[2]{ {"sort",1} {"good",2}};

	return 0;
}

```

![image-20220607222025699](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607222025699.png)

#### {}的类型

{}在C++11里面是一个类型，initializer_list,[initializer_list - C++ Reference (cplusplus.com)](http://m.cplusplus.com/reference/initializer_list/initializer_list/)，也叫初始化列表。

```cpp
template<class T> 
class initializer_list;
```

![image-20220607222518275](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607222518275.png)

**initializer_list提供了迭代器，所以可以遍历列表内的元素。**

![image-20220607223613220](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607223613220.png)

以vector为例，里面提供了这种类型的构造函数，所以vector < int > v{1,2,3}这种用法就是在调用构造函数

> 我们可以想想可以怎么实现这个功能，遍历initializer_list的元素，挨个赋值给vector容器即可。（没看库里怎么实现的，不过是阐述一种可行的思路

![image-20220607224008553](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607224008553.png)

**STL库中的大多容器都增加了initializer_list相关的构造函数**

> 用初始化列表可以加强类型安全。比如int a=1.2,最后a存储的是1，这就是类型收窄。一些初始化列表的使用会导致了类型收窄，这是不合法的（编译器报错），总之建议使用初始化列表初始化。

### auto

> C++98是有auto的，不过在C++11被废弃了，我们现在的int a，就是C++98的auto int a

auto是一个存储类型的说明符，作用是推导类型。

#### 简单实例

```cpp
int main()
{
	auto a = 0;
	auto b = 1L;
	auto c = 1.1;
	std::vector<std::string>::iterator it;
	auto d = it;
	
	return 0;
}
//如果有一个类型很长比如std::vector<std::string>string_v;还要去写它的迭代器就更麻烦了，这种情况下就可以用auto去代替
```

![image-20220607233155376](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607233155376.png)

auto一定程度的降低了程序的可读性，并且我们**不应该滥用auto**.

> 滥用auto看起来更方便，实际上会造成很多问题，比如难以维护，再比如
>
> ```c++
> string str="ccl";
> auto s=str;
> s.size();
> //上面的代码是合理的，但是当我们有一天将string改为const char*时，虽然auto方面没有问题，但是依赖于string类型的代码全部出问题了。
> ```

### decltype

将变量的类型指定为一个表达式的类型

![image-20220607233928651](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607233928651.png)

> typeid(z).name返回的是一个字符串，所以肯定不能拿其返回值当类型了



### nullptr

nullptr是一个对象，nullptr的类型是nullptr_t,并不等同于（(void*)0）,nullptr可以隐式的转为任意类型的指针,同时nullptr不能取地址。此外由于nullptr有类型所以是可以捕捉异常的。

![image-20220607234830446](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220607234830446.png)

>```cpp
>//网上找的一种可能的实现
>struct nullptr_t
>{
>    void operator&() const = delete;  
>    template <class T>
>    inline operator T*() const
>    {
>        return 0;
>    }
>    template <class C, class T>
>    inline operator T C::*() const
>    {
>        return 0;
>    }
>};
>
>nullptr_t nullptr;
>```

### 范围for

遍历容器内的所有元素，如果要修改需要加引用，本质上就是迭代器的遍历。

![image-20220608000055391](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608000055391.png)

> VS监视小技巧
>
> ![image-20220608000428468](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608000428468.png)

### 左右值引用

#### 左值和右值是什么

左值就是可以取地址的，右值就是不可以取地址的。

> 我们经常可以知道一些关于左右值的判断，而很少听到其真正的定义的一个原因是很难归纳，而且就算归纳了，也需要大量的解释。--《深入理解C++11》

右值由两个概念构成，一个是将亡值，一个是纯右值，也有人说右值的别名就是将亡值，因为生动形象，这里我们采用后一种说法。

> 也有人把左右值定义为，左值可以读写，右值只能读不能写。

#### 左值和右值的区分

- 赋值表达式中，左边的全是左值，右边的不一定都是右值,但是右值一点在右边。~~听起来有点绕~~

```c++
int main()
{
	int i = 1;
	int j = i;
	return 0;
}
```

![image-20220608103548992](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608103548992.png)

比如a=b+c,&(b+c)编译时报错，即(b+c)的结果是一个临时变量不能取地址，所以b+c是右值，a是左值。

- 将亡值，听名字就知道是一个即将死亡的值，换句话说，生命周期结束的值。比如一些临时变量的值，一些字面值，lambda表达式，都可以看做右值（将亡值）。

🌰<font color=#00CED1> **1，‘a‘ , true**</font>之类的都是字面值，也都是右值

🌰 一些临时变量，比如一些函数的返回值（返回值是引用的另说），<font color=#00CED1>**1+3，“123”+“456”，lambda表达式，函数sum(1,2)的返回值，**</font>这些都是右值，将亡值的概念用在这就十分合适，用完就销毁了。

#### 左右值引用

- 左值引用，接收左值的引用+const引用

比如T& 和const T&，const T&可以接受右值

> const引用可以理解为接收一个临时的左值。

move(左值)的作用是把这个左值转为一个右值，但是也可能带来一些问题，比如数据丢失。

- 右值引用，T&&，两个&是为了区分是左值引用还是右值引用

```c++
int main()
{
	int a = 1;

	//左值引用
	int& b = a;
	const int& x = 1;//const引用是例外
	int& c = 5;//err

	//右值引用
	int&& m = 1;
	int&& n = a;//err
	int&& p = move(a);
	

	return 0;
}

```

![image-20220608105506083](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608105506083.png)

#### 左右值引用的作用

看到这，大概对左右值有了一个大概的认识。左值引用我们之前就知道，作用是可以减少拷贝，一定程度上替代了指针（指针有些地方是无法替代的），右值引用的作用是实现移动语义和完美转发。

移动语义：减少拷贝，提高效率

完美转发：保持原来的值属性不变。比如传参，左值传过去还是左值，右值传过去还是右值，利用这一点也可以提高程序的性能，比如减少拷贝。

简单来说，右值引用提高了程序的性能。（在某些场景下提升很大）

#### 移动语义

假如现在需要一个一次性对象A来拷贝构造另一个生命周期更长的对象B，一次性对象A用完就销毁了，但是拷贝构造B前还是得去构造这个一次性对象A，是不是觉得有点浪费。

反正这个一次性对象A的作用也是拷贝出另一个对象B，反正一次性对象A用完就要销毁了，那我们有没有一种办法把A的资源“偷走”给拷贝出来的对象B，这样不就可以减少一次拷贝构造。

**移动语义可以解决这个问题。**

##### 场景

看下面的场景

```c++
class String
{
public:
	String() = default;
	String(const char* string)
	{
		printf("构造\n");
		_size = strlen(string);
		_string = new char[_size];
		memcpy(_string, string, _size);
	}
	String(const String& other)
	{
		printf("深拷贝\n");
		_size = other._size;
		_string = new char[_size];
		memcpy(_string, other._string, _size);
	}
	~String()
	{
		delete[] _string;
	}
	void Print()
	{
		for (size_t i = 0; i < _size; i++)
		{
			printf("%c", _string[i]);
		}
		printf("\n");
	}
private:
	char* _string;
	size_t _size;
};
class Entity
{
public:
	Entity(const String& name)//可以看出构造出来的就只在这里用了
		:_name(name)//拷贝构造
	{
		printf("构造Entity\n");
	}
	void PrintName()
	{
		_name.Print();
	}
private:
	String _name;
};
int main()
{
	Entity entity("ccl");
	entity.PrintName();
	return 0;
}
```

场景中打印entity对象的名字就得需要先构造一个临时对象name，再拿临时对象name去拷贝构造出Entity类的成员_name，这就是两次深拷贝。

![image-20220608222643810](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608222643810.png)

运行结果也印证了深拷贝两次。

![image-20220608222754375](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608222754375.png)

**那移动语义怎么解决这个问题呢？**

或者说移动语义怎么做到偷走它的资源的呢。思路上就是把要用的指针指向本该销毁的内存，再把一次性对象的指针置空，之后一次性对象生命周期结束调用析构函数也不过是delete nullptr，这是合法的。

具体代码可以这样做：

String增加一个移动构造，Entity的构造也增加一个右值的版本由于匹配右值“ccl”

看看具体的更改：

![image-20220608225342604](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608225342604.png)

![image-20220608225449646](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608225449646.png)

代码汇总：

```c++
class String
{
public:
	String() = default;
	String(const char* string)
	{
		printf("构造\n");
		_size = strlen(string);
		_string = new char[_size];
		memcpy(_string, string, _size);
	}
	String(const String& other)
	{
		printf("深拷贝\n");
		_size = other._size;
		_string = new char[_size];
		memcpy(_string, other._string, _size);
	}
	String(String&& other) noexcept//提供一个移动构造的函数 参数是右值
	{
		_string = other._string;
		_size = other._size;
		other._string = nullptr;//必须处理这个临时的字符串，不然两个指针指向同一块内存
		other._size = 0;
	}
	~String()
	{
		delete[] _string;
	}
	void Print()
	{
		for (size_t i = 0; i < _size; i++)
		{
			printf("%c", _string[i]);
		}
		printf("\n");
	}
private:
	char* _string;
	size_t _size;
};
class Entity
{
public:
	Entity(const String& name)//可以看出构造出来的就只在这里用了
		:_name(name)//拷贝构造
	{
		printf("构造Entity\n");
	}
	Entity(String&& name)
		:_name(std::move(name))//move可以把左值转换为右值，用于匹配String的移动构造
	{
		printf("移动构造Entity\n");
	}
	void PrintName()
	{
		_name.Print();
	}
private:
	String _name;
};
int main()
{
	Entity entity("ccl");
	entity.PrintName();
	return 0;
}
```

再来看看结果

![image-20220608225904337](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608225904337.png)

比对一下增加移动拷贝前后的结果

![image-20220608230123206](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608230123206.png)

**<font color=red>最后，移动语义本质上允许我们移动对象，换句话说你可以吧一个已经存在的变量转成临时变量，你可以从这个特定的变量中窃取资源，也就达到了提高性能的目的。</font>**

##### move

move的作用就是将左值转为右值。

上面通过拷贝构造窃取了资源，那假如我们想通过赋值来直接窃取资源呢？重载=即可。

注意点：处理旧数据，不能窃取自己的资源，防止一块内存被析构两次

```c++
String& operator=(String&& other)
{
	if (this != &other)//窃取的不是自己的资源
	{
		//处理旧数据，防止内存泄漏
		delete[] _string;
		//窃取资源
		_string = other._string;
		_size = other._size;
		//防止一块内存被析构两次
		other._string = nullptr;
		other._size = 0;
        return *this;
	}
}
```

调用时得用move转成右值取匹配赋值的右值版本。

![image-20220608232052126](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608232052126.png)

#### 完美转发



### 可变参数模板

[高清 1080P 侯捷——C++11新特性 P4 4 Unifrom Initialization - YouTube](https://www.youtube.com/watch?v=D7TazdajyVI&list=PL-X74YXt4LVYo_bk-jHMV5T3LHRYRbZoH&index=3)

### STL增加的容器

![image-20220608000710231](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220608000710231.png)

可以看出加了四个容器。

- array，这个容器可以放越界，因为重载了operator[]，越界直接报错，这也算是一个优点了...

> 原生数组的越界的检查得看编译器，有时检查的到有时检查不到，有点玄学

- forward_list,单链表，list也是链表，不过底层是双向循环链表。所以forward_list的好处就是每个元素少存储了一个指针，少四个字节，一百万个元素也就是四百万个字节，也就是4M左右。也算是优点吧。。。此外forward_list没有提供尾插尾删，单链表尾插尾删要找尾，效率不高，所以没有提供相应的接口。

- unordered_map和unordered_set就比较有用了，传送门👉[unordered_set与set的比较](https://blog.csdn.net/m0_53005929/article/details/124852681?spm=1001.2014.3001.5501)

### lambda表达式

[【59】【Cherno C++】【中字】C++的lambda_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV195411A7KX?spm_id_from=333.999.0.0)

### 包装器















左右值引用，给旧容器增加了一些接口  比如vector的push_back多了一个版本

![image-20220601122629323](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220601122629323.png)





右值引用 &&用于区分左值引用

左值引用 左值的引用就是左值引用 &

什么是左值？常变量也是左值（可以取地址）

左值可以被修改   左值出现在赋值符号的左边和右边

右值只能出现在赋值符号的右边，**不能取地址**，不能修改

![image-20220601123231468](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220601123231468.png)

最明显的差别在于能否取地址  所以const修饰的变量（常变量左值）

左边的一定是左值 右边的可能是左值也可能是右值



表达式的值如果是一个临时变量或者对象也算右值

如果结果是引用算左值

单个变量是引用也可以认为是左值



右值引用后被存储到一个特定的位置





左值能给右值取别名吗？

> 但是const左值引用既可以左值也可以引用右值，因为有这样的需求

![image-20220601163554175](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220601163554175.png)

右值引用能引用左值吗？（给左值取别名） 报错是什么？能否连续引用？

如果我硬要引用左值该怎么做？移动语义

连续引用已经变成左值了，所以还需要move。



选最合适的

![image-20220601164636955](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220601164636955.png)





左右值引用的目的都是减少拷贝

那有什么区别？

static在函数结束后还在

 



右值引用的场景 将亡值



![image-20220601171529210](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220601171529210.png)



string析构时把size和capacity都置为0了



编译器优化 如果存在连续的构造等就会进行优化

为什么不直接进行优化？当没有对象接收时如果不产生临时变量会出问题，拿到的就是随机值

左值引用无法解决的问题

几乎没有场景用于右值返回



利用将亡值的特点提高效率 接管即将销毁的空间 减少了一次拷贝构造

本来是两次移动构造 编译器优化成一次   画出这个场景图

防止中间商赚差价

不优化的情况下，不管是左值还是右值都是两次构造 只是移动构造效率比左值效率要高不少



![image-20220602011317497](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220602011317497.png)



![image-20220602012442697](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220602012442697.png)



C++11里的STL都提供了右值引用的接口



万能引用  右值接受后变成左值



用move时得注意可能把数据转走了

完美转发的场景和作用



写一个类去验证左右值拷贝



给缺省值

const静态成员可以给缺省值   静态成员不行

类里面只是声明



默认的移动拷贝是什么？



新增的几个关键字



main的可变参数

[main函数参数解析和可变函数列表_smile_zhangwj的博客-CSDN博客](https://blog.csdn.net/smile_zhangw/article/details/81098343)





模板参数包

可以知道有几个参数 但是不能通过下标取不出具体的参数

要取出具体的参数得通过递归

![image-20220603224005552](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220603224005552.png)



逗号表达式展开参数包



list的empalce和push_back的比较 



lambda表达式



可调用类型定义即具象

![image-20220603234807205](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220603234807205.png)

有点像匿名函数

 

四个参数

捕捉列表  直接捕捉是传值捕捉+不能修改的 需要mutable

四种捕捉规则

只能捕捉父作用域 

![image-20220604004006974](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220604004006974.png)

![image-20220604004537768](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220604004537768.png)







包装器

函数的参数和返回值一样

可以给函数指针  lambda表达式一个名字

有点像给函数起别名

绑定静态和非静态的成员函数  

![image-20220604145149114](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220604145149114.png)



包装器也可以理解为仿函数



绑定 函数模板

占位符 

绑定  固定参数的值

绑定成员函数 可以简化成员函数的用法

调整参数的顺序



线程库



