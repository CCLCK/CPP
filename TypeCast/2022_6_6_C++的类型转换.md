# C++类型转换

## C语言风格的转换

C语言提供了自己的一套转换规则，有好处也有坏处。

  C语言的风格：（type_name）expression;

 C语言提供了隐式类型转换和显式类型转换。显式类型转换一般也叫做强转，隐式类型转换编译器完成，如果转换不了就报错。

 而C语言类型转换的风格好处就是简单，缺陷比如转换的可视性差，显式类型转换的写法就只有一种，难以精准的跟踪错误。

 🌰char ch=1.1，char ch=1在.cpp下都是合法的，这就是隐式类型转换，C语言下如果把一个结构体给int就会报错，因为编译器不知道怎么去转，**C++**下可以通过实现operator int()实现类型转换或者提供**合适的**构造函数完成隐式类型转换，下面以在.cpp中实现operator int()为例

 ![image-20220611220824779](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220611220824779.png)

 下面这段代码由于隐式类型转换导致了死循环

 ![image-20220611221539297](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220611221539297.png)

C语言的类型转换其实已经足够完成需求了，但是可视性不太好，比如你不能在代码库中搜索它（就一对括号怎么去搜索），所以C++提供了一套类型转换，相当于语法糖了，此外还会进行一些编译性检查（比如dynamic_cast转换失败则返回空指针）。但其实作用都是一样的。

## C++风格的类型转换

C++标准为了增加类型转换的可见性，提供了四种类型转化的方式。

### static_cast 

静态类型转换，也叫隐式类型转换，但不能转换两个不相关的类型（即编译器看到这个转换是行不通的就会报错）。

static_cast < type-id > ( expression )

```c++
int main()
{

	double a = (int)5.5 + 5.3;//结果是10.3

	double b = static_cast <int>(5.5) + 5.3;

	cout << "a: " << a << endl;
	cout << "b: " << b << endl;
	return 0;
}
```

![image-20220611224919777](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220611224919777.png)

转换不相关的类型：

![image-20220611225312856](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220611225312856.png)

### reinterpret_cast

很暴力的一个操作符，由英文直接译过来就是重新解释的转型。白话就是将一段内存重新解释。

> 网上看到很多大佬的理解，这里借用或掺杂自己的思想：static_cast是做类型能做的转换，不行编译器就报错，告诉你这样是不合理的，reinterpret_cast则是就算不能转换编译器你也别报错，我心里有数。由于reinterpret_cast本质上是一个编译器指令，所以实际动作完全取决于编译器，失去了移植性。
>
> 暴力归暴力，但也是合理范围内的，比如你把一个结构体硬塞给int肯定是不行的，但是把结构体指针重新解释为int那是一点问题没有。
>
> 此外reinterpret_cast重新解释的办法是把那一块内存的比特位全部复制下来重新解释。

下面的例子把一个结构体指针解释为int再加上5.3。

```c++
struct Test
{
	int a;
};
int main()
{
	Test* t = new Test;
	double c = reinterpret_cast <int>(&t) + 5.3;
	cout << c << endl;
	
	return 0;
}
```



![image-20220611232448129](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220611232448129.png)

### const_cast

删除变量的const属性



### dynamic_cast

## 补充的关键字

### volatile



static_cast 相关类型转换，不能完成不相关类型的转换

reinterpret_cast 显式的强制类型转换

const_cast const的类型转换 可以取消const属性

![image-20220606171321495](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220606171321495.png)

volatile 告诉编译器去内存取

dynamic_cast 多态的转换 向下转换（父类转为子类）是安全的的  父类必须有虚函数

父类的指针指向父类对象，给到子类指针，存在越界的风险（强制类型转换）

父类的指针指向子类对象，给到子类指针，合理

所以建议使用dynamic_cast 安全  第一种转换失败返回空指针 第二种成功

[【69】【Cherno C++】【中字】C++的类型转换_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1N54y1j7hM?spm_id_from=333.999.0.0&vd_source=68554a723b373e22a24bbc1d3c5ec4c1)

[【68】【Cherno C++】【中字】C++的虚析构函数_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1dK411w7Gg?spm_id_from=333.999.0.0&vd_source=68554a723b373e22a24bbc1d3c5ec4c1)

[【54】【Cherno C++】【中字】C++的堆与栈内存的比较_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1CK4y1n7N2?spm_id_from=333.999.0.0)

[【5】【Cherno C++】【中字】C++是如何工作的_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Bi4y1V7zb?spm_id_from=333.999.0.0&vd_source=68554a723b373e22a24bbc1d3c5ec4c1)